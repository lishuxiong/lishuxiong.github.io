<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[android java代码执行shell命令]]></title>
      <url>/2017/08/03/android-java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>java代码执行shell命令<br><a id="more"></a></p>
<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>获取Android中当前正在使用app的包名。</p>
<p>网上解决方案，尝试了很多种不行<br>(1)android5.0之前可以使用getRunningTask()获取。现在不行，当app是系统app(/system/app/下)，并且系统签名情况下,申请权限android:name=”android.permission.GET_TASKS”，可以拿到自己的包信息，如果当前正在使用其他app，是不能拿到的。</p>
<p>(2)getRunningAppProcesses()获取，返回null，也是权限问题。</p>
<p>以上2种情况，都是因为5.0后系统添加了权限判断<br>(boolean allowed = checkPermission(android.Manifest.permission.REAL_GET_TASKS,  callingPid,callingUid)==PackageManager.PERMISSION_GRANTED; 权限判断方法)。导致普通app无法使用，获取不到。</p>
<p>(3)UsageStatsManager 中queryUsageStats(…)查询最近使用的app记录，然后用一个最小时间(最近时间)来过滤出当前正在使用的app，目前，在7.0上面测试获取的是null。有人说能成功，具体机型和系统版本有待验证。</p>
<h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>通过代码不行，有没有其他方式呢，平时看logcat都有好多app包名信息的,logcat是adb下的命令，想到命令，是否可以通过命令来获取呢，google了一下果然有。(思考解决问题的一种方式)</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>java中执行shell命令。我们都知道Android基于linux，app是一个单独的进程，那么在运行时，我们就可以执行shell命令。<br>Runtime runtime = Runtime.getRuntime();拿到app运行时的Runtime 对象;<br>Process proc = runtime.exec(“具体的命令”);<br>proc.waitFor()执行结果code 0表示成功;</p>
<p>先上我的解决方法(代码)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private String getForegroundApp() &#123;</div><div class="line">    String packageName = &quot;&quot;;</div><div class="line">    try &#123;</div><div class="line">        String command[] = new String[]&#123;&quot;sh&quot;, &quot;-c&quot;,</div><div class="line">                &quot;dumpsys activity | grep \&quot;ACTIVITY MANAGER RECENT TASKS\&quot; -A 10 |grep \&quot;Recent tasks:\&quot; -A 1&quot;&#125;;</div><div class="line">        //&quot;dumpsys window | grep mCurrentFocus&quot;</div><div class="line">        Process process = Runtime.getRuntime().exec(command);</div><div class="line">        int code = process.waitFor();</div><div class="line">        Log.d(TAG, &quot;code ： &quot; + code);</div><div class="line">        StringBuilder successMsg = new StringBuilder();</div><div class="line">        StringBuilder errorMsg = new StringBuilder();</div><div class="line">        BufferedReader successResult = new BufferedReader(new InputStreamReader(process.getInputStream()));</div><div class="line">        BufferedReader errorResult = new BufferedReader(new InputStreamReader(process.getErrorStream()));</div><div class="line">        String s;</div><div class="line">        while ((s = successResult.readLine()) != null) &#123;</div><div class="line">            successMsg.append(s);</div><div class="line">        &#125;</div><div class="line">        while ((s = errorResult.readLine()) != null) &#123;</div><div class="line">            errorMsg.append(s);</div><div class="line">        &#125;</div><div class="line">        Log.d(TAG, &quot;successMsg ： &quot; + successMsg);</div><div class="line">        Log.d(TAG, &quot;errorMsg ： &quot; + errorMsg);</div><div class="line">        String content = successMsg.toString();</div><div class="line">        if (content.contains(&quot;A&quot;) &amp;&amp; content.contains(&quot;U&quot;)) &#123;</div><div class="line">            int indexA = content.lastIndexOf(&quot;A&quot;);</div><div class="line">            int indexU = content.lastIndexOf(&quot;U&quot;);</div><div class="line">            packageName = content.substring(indexA + 2, indexU - 1);</div><div class="line">            Log.d(TAG, &quot;content ： &quot; + packageName);</div><div class="line">            return packageName.trim();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return packageName.trim();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码分析：command数组，它定义了一组可以执行的命令。 sh:linux环境下执行, -c: 系统命令, ”dumpsys activity”:查看当前的活跃进程的activity。后面的grep命令是过滤出我自己需要的正在使用的app的包名，具体命令意思不多解释。<br>“dumpsys window | grep mCurrentFocus” 查看当前显示的window。grep的作用同上。<br>Runtime.getRuntime().exec(command)，然后是执行command命令组，<br>process.waitFor()拿到执行返回的code值。创建StringBuilder：successMsg和errorMsg来记录执行命令后具体的返回结果信息。最后一个if判断，并拿具体的包名return;(注意：有io操作，如果信息量很大需要放在线程中执行)。这个方法可以准确的拿到当前app具体的包名，同时有2个必要条件：一个是系统app，同时是系统签名app，另一个是需要申请权限android:name=”android.permission.DUMP”</p>
<h1 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h1><p>用代码执行shell命令，解决实际开发中问题也有很多场景。<br>1: Android root权限静默安装或卸载应用，原理是执行命令：pm install apkFilePath及pm uninstall packageName<br>2: 获取系统设置-&gt;存储-&gt;首选安装位置 原理是执行命令：pm get-install-location<br>3: Android代码修改hosts文件<br>mount -o rw,remount /system<br>echo “127.0.0.1 localhost” &gt; /etc/hosts<br>echo “185.31.17.184 github.global.ssl.fastly.net” &gt;&gt; /etc/hosts<br>chmod 644 /etc/hosts<br>4:拷贝文件<br>5：logcat 记录异常信息。<br>6: ps(Process status )查看进程状态的命令，该命令显示瞬间进程的状态(过滤自己需要信息)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>java代码执行shell命令很多，使用的场景也很多，有时可以解决我们实际开发中不少问题，这里只是简单记录。<br>最后如果大家需要可以去看下ShellUtils工具类。地址：<br><a href="https://github.com/Trinea/android-common/blob/master/src/cn/trinea/android/common/util/ShellUtils.java" target="_blank" rel="external">https://github.com/Trinea/android-common/blob/master/src/cn/trinea/android/common/util/ShellUtils.java</a></p>]]></content>
      
        
        <tags>
            
            <tag> Android java shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[android中AIDL详解]]></title>
      <url>/2017/07/25/android%E4%B8%ADaidl%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>aidl详解，使用<br><a id="more"></a></p>
<h1 id="跨进程通讯"><a href="#跨进程通讯" class="headerlink" title="跨进程通讯"></a>跨进程通讯</h1><p>我们都知道在android开发中，每一个进程都有自己的Dalvik VM实例，对应的所有操作都是在自己内部进行，如果进程A要访问进程B的数据，<br>就要通过特殊的渠道或者规则去访问，也就是进程间的通讯，android中也提供了多种访问访问方式，<br>例如Activity ContentProvider Broadcast Service，这里只描述service对应的aidl。</p>
<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p>AIDL是一个缩写，全称是Android Interface Definition Language，是android接口定义语言。(相关知识点service，Binder,Messenger,序列化,这里不多做介绍)</p>
<p>文件类型：aidl文件的后缀是 .aidl</p>
<p>支持数据类型：byte，short，int，long，float，double，boolean，char，String,CharSequence,<br>List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable,List可以使用泛型。<br>Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的.</p>
<p>定向tag：AIDL中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，<br>而 inout 则表示数据可在服务端与客户端之间双向流通。</p>
<h1 id="aidl的创建"><a href="#aidl的创建" class="headerlink" title="aidl的创建"></a>aidl的创建</h1><h2 id="首先定义aidl接口文件"><a href="#首先定义aidl接口文件" class="headerlink" title="首先定义aidl接口文件"></a>首先定义aidl接口文件</h2><p><img src="http://opdge5lf7.bkt.clouddn.com/aidl_1.png" alt="image"></p>
<h2 id="定义业务接口，和自定义数据类型aidl文件"><a href="#定义业务接口，和自定义数据类型aidl文件" class="headerlink" title="定义业务接口，和自定义数据类型aidl文件"></a>定义业务接口，和自定义数据类型aidl文件</h2><p><img src="http://opdge5lf7.bkt.clouddn.com/aidl_2.png" alt="image"></p>
<font color="#FF0000" size="3" face="重点，重点，重点">重点，重点，重点，注意import包名，当前引用的类的全路径一定要正确</font>



<h2 id="定义实际的数据结构，注意包名和结构一定和aidl中的一致。"><a href="#定义实际的数据结构，注意包名和结构一定和aidl中的一致。" class="headerlink" title="定义实际的数据结构，注意包名和结构一定和aidl中的一致。"></a>定义实际的数据结构，注意包名和结构一定和aidl中的一致。</h2><p><img src="http://opdge5lf7.bkt.clouddn.com/aidl_3.png" alt="image"></p>
<font color="#FF0000" size="3" face="重点，重点，重点">注意包名和结构一定和aidl中的一致</font>



<h2 id="客户端对应aidl文件和服务端一样。可以参照对比"><a href="#客户端对应aidl文件和服务端一样。可以参照对比" class="headerlink" title="客户端对应aidl文件和服务端一样。可以参照对比"></a>客户端对应aidl文件和服务端一样。可以参照对比</h2><p>服务端项目结构图：<br><img src="http://opdge5lf7.bkt.clouddn.com/aidl_4.png" alt="image"></p>
<p>客户端项目结构图：<br><img src="http://opdge5lf7.bkt.clouddn.com/aidl_56.png" alt="image"></p>
<h1 id="aidl服务端实现"><a href="#aidl服务端实现" class="headerlink" title="aidl服务端实现"></a>aidl服务端实现</h1><h2 id="AbstractAccount类"><a href="#AbstractAccount类" class="headerlink" title="AbstractAccount类"></a>AbstractAccount类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">abstract class AbstractAccount &#123;</div><div class="line"></div><div class="line">    private Transport mTransport = new Transport();</div><div class="line"></div><div class="line">    private class Transport extends IAccountAPI.Stub &#123;</div><div class="line">        @Override</div><div class="line">        public String getName() throws RemoteException &#123;</div><div class="line">            return getNameInfo();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void getAccount(Request request, IAccountCallback cb) throws RemoteException &#123;</div><div class="line">            getAccountInfo(request,cb);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract String getNameInfo();</div><div class="line"></div><div class="line">    public abstract void getAccountInfo(Request request, IAccountCallback cb);</div><div class="line"></div><div class="line">    public final IBinder getIBinder() &#123;</div><div class="line">        return mTransport.asBinder();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义的业务接口IAccountAPI.aidl,文件，compile后生成对应的aidl文件，其中IAccountAPI.Stub是继承了Binder并实现了IAccountAPI接口的类，<br>在这里我做一层装的，定义Transport类，继承IAccountAPI.Stub并重写业务接口中的2个方法。同时定义2个抽象方法提供给外部具体实现。<br>getIBinder()返回绑定的Binder对象。</p>
<h2 id="AccountImp类"><a href="#AccountImp类" class="headerlink" title="AccountImp类"></a>AccountImp类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class AccountImp extends AbstractAccount &#123;</div><div class="line"></div><div class="line">    //如果需要使用Context</div><div class="line">    private Context mContext;</div><div class="line"></div><div class="line">    public AccountImp(Context context) &#123;</div><div class="line">        this.mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getNameInfo() &#123;</div><div class="line">        //这里直接返回测试数据</div><div class="line">        return &quot;张三and李四&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void getAccountInfo(Request request, IAccountCallback cb) &#123;</div><div class="line">        Account account = new Account();</div><div class="line">        account.name = &quot;lisx&quot;;</div><div class="line">        account.age = 27;</div><div class="line">        //这里在包装一层对象，方便返回更多信息</div><div class="line">        Response response = new Response();</div><div class="line">        response.account = account;</div><div class="line">        try &#123;</div><div class="line">            //这里直接使用接口，回调数据对象、当然也可以直接return返回，取决于自己定义的aidl接口</div><div class="line">            cb.onResponse(response);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的服务端实现类，数据的返回，可以return，或者类似接口回调（IAccountCallback，作用：异步回调客户端）</p>
<h2 id="AccountService类"><a href="#AccountService类" class="headerlink" title="AccountService类"></a>AccountService类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class AccountService extends Service &#123;</div><div class="line"></div><div class="line">    private static AccountImp accountImp;</div><div class="line"></div><div class="line">    public AccountService() &#123;</div><div class="line">        accountImp = new AccountImp(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return accountImp.getIBinder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</div><div class="line">        return START_REDELIVER_INTENT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>简单的服务类accountImp.getIBinder(),返回aidl绑定的IBinder对象</p>
<h2 id="AndroidManifest-xml类"><a href="#AndroidManifest-xml类" class="headerlink" title=" AndroidManifest.xml类"></a> AndroidManifest.xml类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=&quot;.auth.AccountService&quot;</div><div class="line">    android:exported=&quot;true&quot;&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name=&quot;com.putao.ptx.kotlin.BIND_ACCOUNT_SERVICE&quot; /&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure>
<p>注册service，注意action，对应客户端启动绑定服务时一定要保持一致。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title=" 总结"></a> 总结</h2><p> 至此服务端代码算是写完(具体原理最后分析)，其中有许多细节需要注意：<br> (1）aidl文件写好后，编译gradle命令 compileDebugAidl,或者androidstudio右边的gradle-&gt;other-&gt;compileDebugAidl。<br> (2）编译后会生成对应java文件，在当前moudle下的build-&gt;genrated-&gt;source-&gt;debug中，这个java文件请一定仔细查看，查看对应包名，数据类型，stub等。<br><img src="http://opdge5lf7.bkt.clouddn.com/aidl_7.png" alt="image"><br> (3）aidl的自定义数据类型 Account.aidl 注意parcelable 小写，对应的java的的实体Account要实现Parcelable并且包名一定要一致;<br> (4）AccountService在AndroidManifest中需要注册，并设置android:exported=”true”允许外部访问。</p>
<h1 id="aidl客户端实现"><a href="#aidl客户端实现" class="headerlink" title=" aidl客户端实现"></a> aidl客户端实现</h1><h2 id="AccountManager类（本篇博客精华所在，其他内容网上大同小异，客户端的使用以及本类的处理方法才是我写这篇博客的原因）"><a href="#AccountManager类（本篇博客精华所在，其他内容网上大同小异，客户端的使用以及本类的处理方法才是我写这篇博客的原因）" class="headerlink" title=" AccountManager类（本篇博客精华所在，其他内容网上大同小异，客户端的使用以及本类的处理方法才是我写这篇博客的原因）"></a> AccountManager类（本篇博客精华所在，其他内容网上大同小异，客户端的使用以及本类的处理方法才是我写这篇博客的原因）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">public class AccountManager &#123;</div><div class="line"></div><div class="line">    private static final String TAG = AccountManager.class.getSimpleName();</div><div class="line">    //要绑定服务端的包名</div><div class="line">    private static final String PACKAGE_ACCOUNT = &quot;com.putao.ptx.kotlin&quot;;</div><div class="line">    //要绑定对应服务端的action</div><div class="line">    private static final String BIND_AUTH_SERVICE = &quot;com.putao.ptx.kotlin.BIND_ACCOUNT_SERVICE&quot;;</div><div class="line">    //当前上下文</div><div class="line">    private Context context;</div><div class="line">    //标记客户端是否连接服务端成功</div><div class="line">    private boolean connected;</div><div class="line">    //业务接口</div><div class="line">    private IAccountAPI api;</div><div class="line">    //同步锁</div><div class="line">    private final Object lock = new Object();</div><div class="line">    //更新界面Handler</div><div class="line">    private Handler mHandler;</div><div class="line"></div><div class="line">    //当前AccountManager的构造方法，实际操作AccountManager应该是单例。</div><div class="line">    public AccountManager(Context context, Handler handler) &#123;</div><div class="line">        this.context = context.getApplicationContext();</div><div class="line">        this.mHandler = handler;</div><div class="line">        bindServiceIfNeeded();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 说明：绑定service</div><div class="line">     */</div><div class="line">    private void bindServiceIfNeeded() &#123;</div><div class="line">        if (!connected) &#123;</div><div class="line">            Intent intent = new Intent(BIND_AUTH_SERVICE);</div><div class="line">            intent.setPackage(PACKAGE_ACCOUNT);</div><div class="line">            boolean result = context.bindService(intent, new ServiceConnection() &#123;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">                    api = IAccountAPI.Stub.asInterface(service);</div><div class="line">                    synchronized (lock) &#123;</div><div class="line">                        connected = true;</div><div class="line">                        lock.notifyAll();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onServiceDisconnected(ComponentName name) &#123;</div><div class="line">                    api = null;</div><div class="line">                    synchronized (lock) &#123;</div><div class="line">                        connected = false;</div><div class="line">                        lock.notifyAll();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;, Context.BIND_AUTO_CREATE);</div><div class="line">            Log.d(TAG, &quot;result:&quot; + result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 说明：等待客户端绑定服务端并返回是否绑定成功</div><div class="line">     * return boolean</div><div class="line">     */</div><div class="line">    private boolean waitForAccess() &#123;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        synchronized (lock) &#123;</div><div class="line">            if (!connected) &#123;</div><div class="line">                try &#123;</div><div class="line">                    lock.wait(2000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Log.d(TAG, &quot;waitForAccess spent:&quot; + (System.currentTimeMillis() - start));</div><div class="line">        return connected;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 说明：封装，实际调用业务接口getName()，获取服务端返回的数据（同步）</div><div class="line">     * return String</div><div class="line">     */</div><div class="line">    public String getName() &#123;</div><div class="line">        bindServiceIfNeeded();</div><div class="line">        //同步获取数据，会阻塞住线程</div><div class="line">        String name = &quot;&quot;;</div><div class="line">        if (waitForAccess()) &#123;</div><div class="line">            try &#123;</div><div class="line">                name = api.getName();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 说明：封装，实际调用业务接口getAccount()，获取服务端返回的数据（异步）</div><div class="line">     * 由于是异步所以不能直接返回数据，拿到数据可自行处理。</div><div class="line">     * return String</div><div class="line">     */</div><div class="line">    public void getAccount() &#123;</div><div class="line">        bindServiceIfNeeded();</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                if (waitForAccess()) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Request request = new Request();</div><div class="line">                        api.getAccount(request, new IAccountCallback.Stub() &#123;</div><div class="line">                            @Override</div><div class="line">                            public void onResponse(Response response) throws RemoteException &#123;</div><div class="line">                                Log.d(&quot;lisx&quot;,response.account.toString());</div><div class="line">                                Message msg = new Message();</div><div class="line">                                msg.obj = response;</div><div class="line">                                mHandler.sendMessage(msg);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先AccountManager类的构造方法赋值，并调用bindServiceIfNeeded()尝试去绑定service端，我们在看<br>bindServiceIfNeeded()方法,先判断connected，如果没有绑定就创建Intent，设置服务端包名和要绑定<br>service的action，之后context调用bindService（…）绑定服务，其中有两个参数，一个intent（不多解释），<br>一个ServiceConnection对象，它是用来回掉绑定service是否成功的结果，成功回掉onServiceConnected（…）<br>失败回掉onServiceDisconnected(…)。</p>
<p>我们先看回掉成功后的onServiceConnected(ComponentName name, IBinder service)方法，参见代码：<br>api =IAccountAPI.Stub.asInterface(service); 这句我们拿到绑定服务端成功后返回的代理对象api，<br>之后我们有一个同步代码块，其中有一个lock同步锁，为什么要有这个呢？我们思考一个问题，客户端绑定服务端是一个过程(具体的绑定以及原理不是本文重点)，绑定结果通过回掉的形式返回结果我们就可以看出来，经过测试这个过程一般是毫秒级别的，同时我做过测试，很多个客户端去绑定service服务端，一般也会在2秒之内返回结果。当然系统卡顿，同时运行的进程很多，内存占用量大等等，都会导致这个绑定时间变长。我们在使用这个api对象的时候，至少需要等到绑定成功并返回结果后才能使用，否则使用时api对象时会报null指针异常，那么绑定服务端回调结果这个时机是不确定的，但是外部通常调用api的方法时候是一次性的，也就是说你调用一次api对象的放法不一定会返回正确的值（调用api对象方法的时候，api刚好是null的，即使你有非null判断，只能保证不会crash，方法执行完，并不会有结果返回）。言归正传，synchronized同步，防止多次绑定返回结果，connected标记是否成功，lock.notifyAll()，成功后及时通知api对象可以使用了。</p>
<p>然后我们在看waitForAccess()方法，synchronized同步，防止多次调用，同时判断connected的值，如果还没有绑定当前线程，就会等待2秒lock.wait(2000)，如果绑定就会直接返回connected的值，此方法会同步阻塞当前线程。</p>
<p>我们在看封装的具体getName()方法，它执行之前会去调用bindServiceIfNeeded()方法绑定一次，之后调用waitForAccess()方法判断是否已经绑定成功，api对象是否可用，确定可用后，然后在执行实际的api.getName()方法，获取service提供的数据。其中有个细节就是waitForAccess()如果在等待中，如果绑定成功或者失败，那么onServiceConnected（…）和onServiceDisconnected(…)中的lock.notifyAll()就会立即通知waitForAccess()中的lock.wait(2000)结束等待并返回结果。</p>
<p>最后我们在看封装的具体getAccount()方法，首先启动一个线程，保证不阻塞当前线程，同时在线程的run方法中调用waitForAccess()判断，之后，api.getAccount(…）调用实际方法，唯一不同的是它是以回调的形式携带具体的service端提供的数据。拿到数据之后大家就可以自行处理的，这边这是简单的handler发送出去更新了下demo界面显示。（为什么要用回掉的形式来携带service的提供的数据呢，大家可以细想下微信授权登录的流程并返回信息，篇幅所限，这里不多做解释，有兴趣可以自己研究为什么这样写）。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>android的IPC大多基于Binder机制，这里所说的aidl也是基于Binder实现一种形式，最后一张图总结下aidl的工作流程，至于原理有兴趣的<br>我们可以共同讨论。</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/aidl_8.png" alt="image"></p>
<p>最后赋上sample的github地址 <a href="https://github.com/lishuxiong/lisxAidl.git" target="_blank" rel="external">https://github.com/lishuxiong/lisxAidl.git</a></p>]]></content>
      
        
        <tags>
            
            <tag> Android aidl 跨进程通讯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java设计模式-工厂模式]]></title>
      <url>/2017/05/27/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>java设计模式之工厂模式详解<br><a id="more"></a></p>
<p>工厂，是一类用以生产货物的大型工业建筑物，现代对工厂也称为“制造厂”、“生产企业”。这是广义的定义，那么具体到我们的编程世界中，工厂也可以被我们抽象成<br>以生产我们需要的功能，代码块，方法，变量等等，那么在面向对象中的编程中，我们使用的最多的一般就是针对对象的“生产”。<br>我们都知道一个对象的生成，需要一个复杂的过程，比如构造方法中一些初始化的赋值，方法的使用等等。有时候我们只关注这个对象本身的而不必要在乎它创建的过程，我们是否可以分装一个类似工厂的生产单元来解决此类问题呢，由此工厂模式的（套路）被大神们总结出来，这里记录一下个人对工厂模式的使用以及理解：</p>
<h1 id="工厂模式的作用"><a href="#工厂模式的作用" class="headerlink" title="工厂模式的作用"></a>工厂模式的作用</h1><p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p>
<h1 id="工厂模式的分类"><a href="#工厂模式的分类" class="headerlink" title="工厂模式的分类"></a>工厂模式的分类</h1><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）<br>GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）<br>简单工厂模式（Simple Factory）归属与工厂方法模式（Factory Method），属于同一类。</p>
<h1 id="工厂模式的一般组成"><a href="#工厂模式的一般组成" class="headerlink" title="工厂模式的一般组成"></a>工厂模式的一般组成</h1><p>1 工厂类角色：这是本模式的核心，含有一定的业务逻辑。在java中它往往由一个具体类实现。</p>
<p>2 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。</p>
<p>3 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。</p>
<h1 id="工厂模式的特点和区别"><a href="#工厂模式的特点和区别" class="headerlink" title="工厂模式的特点和区别"></a>工厂模式的特点和区别</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>工厂方法模式：<br>一个抽象类，可以派生出多个具体的实现类。 （例如：一个服饰厂，可以生产出很多衣服）<br>一个抽象工厂类，可以派生出多个具体工厂类。 （例如：一个服饰厂，可以派生出衣服厂，鞋子厂，帽子厂等等）<br>每个具体工厂类只能创建一个具体产品类的实例。（例如：一个服饰厂中的衣服厂，它只能生产出衣服，而不能生产出鞋子）</p>
<p>抽象工厂模式：<br>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。（例如：衣服厂，鞋子厂，帽子厂（可以看作多个抽象产品类），可以生产出衣服，鞋子，帽子）<br>一个抽象工厂类，可以派生出多个具体工厂类。 （例如：一个服饰厂（抽象工厂类）可以有衣服厂，鞋子厂，帽子厂）<br>每个具体工厂类可以创建多个具体产品类的实例。（例如：衣服厂可以生产衣服）</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。<br>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个</p>
<h1 id="工厂模式的3中具体写法和理解"><a href="#工厂模式的3中具体写法和理解" class="headerlink" title="工厂模式的3中具体写法和理解"></a>工厂模式的3中具体写法和理解</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//产品接口</div><div class="line">public interface Product &#123;</div><div class="line">  public void productName();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//产品实现类ProductA</div><div class="line">public class ProductA implements Product &#123;</div><div class="line">  @Override</div><div class="line">  public void productName() &#123;</div><div class="line">      System.out.println(&quot;product A&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//产品实现类ProductB</div><div class="line">public class ProductB implements Product &#123;</div><div class="line">  @Override</div><div class="line">  public void productName() &#123;</div><div class="line">      System.out.println(&quot;product B&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//工厂类-简单工厂模式</div><div class="line">public class Factory &#123;</div><div class="line">  public ProductI create(String productName) &#123;</div><div class="line">      switch (productName) &#123;</div><div class="line">          case &quot;A&quot;:</div><div class="line">              return new ProductA();</div><div class="line">          case &quot;B&quot;:</div><div class="line">              return new ProductB();</div><div class="line">          default:</div><div class="line">              return null;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//测试类</div><div class="line">public class Client &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">      Factory factory = new Factory();</div><div class="line">      ProductI productA = factory.create(&quot;A&quot;);</div><div class="line">      productA.productName();</div><div class="line">      ProductI productB = factory.create(&quot;B&quot;);</div><div class="line">      productB.productName();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出</div><div class="line">product A</div><div class="line">product B</div></pre></td></tr></table></figure>
<p>首先定义一个接口，其中有一个product（）方法提供生产你想要的对象，接着是两个实现类ProductA，和ProductB具体实现类，最后一个Factory类，生产出需要的对象，不过其中有业务判断逻辑，剩下的就是最后的使用，，获取工厂对象，创建需要的对象，简单工厂的核心就是一个Factory类，我们每次想要增加一种新类型对象的时候，都必须修改Factory的源代码。当我们需要很多中不同类型对象的时候，而且对象之间存在复杂的层次关系的时候，这个Factory类必须拥有复杂的逻辑判断能力，其代码量也将不断地激增，这对以后的维护简直就是恐怖两个字…由此引出工厂方法模式</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">工厂接口</div><div class="line">public interface Factory &#123;</div><div class="line">  // 工厂的目的是为了生产产品</div><div class="line">  public Product create();</div><div class="line">&#125;</div><div class="line"></div><div class="line">工厂实体类 （ProductA ,ProductB,是上面实现了Product接口）</div><div class="line">public class FactoryA implements Factory &#123;</div><div class="line">  @Override</div><div class="line">  public Product create() &#123;</div><div class="line">      return new ProductA();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FactoryB implements Factory &#123;</div><div class="line">  @Override</div><div class="line">  public Product create() &#123;</div><div class="line">      return new ProductB();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  //测试类 工厂方法模式</div><div class="line">public class Client &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">      Factory factoryA = new FactoryA();</div><div class="line">      Product productA = factoryA.create();</div><div class="line">      productA.productName();</div><div class="line">      Factory factoryB = new FactoryB();</div><div class="line">      Product productB = factoryB.create();</div><div class="line">      productB.productName();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>工厂方法是针 对每一种产品提供一个工厂类 。通过不同的工厂实例来创建不同的产品实例，在同一等级结构中， 支持增加任意产品。</p>
<h2 id="抽象工厂类"><a href="#抽象工厂类" class="headerlink" title="抽象工厂类"></a>抽象工厂类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">//产品接口</div><div class="line">public interface ProductAI &#123;</div><div class="line">  public void productName();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//产品接口</div><div class="line">public interface ProductBI &#123;</div><div class="line">  public void productName();</div><div class="line">&#125;</div><div class="line"></div><div class="line">产品实体类</div><div class="line">public class ProductA1 implements ProductAI &#123;</div><div class="line">  @Override</div><div class="line">  public void productName() &#123;</div><div class="line">      System.out.println(&quot;product A1&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">产品实体类</div><div class="line">public class ProductB1 implements ProductAI &#123;</div><div class="line">  @Override</div><div class="line">  public void productName() &#123;</div><div class="line">      System.out.println(&quot;product B1&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 抽像工厂模式</div><div class="line">public interface AbstractFactory &#123;</div><div class="line">  public ProductAI createProductA();</div><div class="line">  public ProductBI createProductB();</div><div class="line">&#125;</div><div class="line"></div><div class="line">工厂实体类</div><div class="line">public class Factory1 implements AbstractFactory &#123;</div><div class="line">  @Override</div><div class="line">  public ProductAI createProductA() &#123;</div><div class="line">      return new ProductA1();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public ProductBI createProductB() &#123;</div><div class="line">      return new ProductB1();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Factory2 implements AbstractFactory &#123;</div><div class="line">  @Override</div><div class="line">  public ProductAI createProductA() &#123;</div><div class="line">      return new ProductA2();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public ProductBI createProductB() &#123;</div><div class="line">      return new ProductB2();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象工厂是应对产品系列概念的,应对产品系列概念而生，增加新的产品线很容易，但是无法增加新的产品。<br>和工厂方法的区别是，抽象工厂往往有多种方法，可以生产多种产品，即一系列产品。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>核心：需要什么对象，不关注过程，只需要结果。</p>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[java设计模式-单例模式]]></title>
      <url>/2017/05/20/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>java设计模式之单例模式详解<br><a id="more"></a></p>
<h1 id="设计模式是什么？"><a href="#设计模式是什么？" class="headerlink" title="设计模式是什么？"></a>设计模式是什么？</h1><p>所谓的设计模式：是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。（ps：觉得应该是应对产品需求所总结出来的套路）</p>
<h1 id="设计模式做什么用的？"><a href="#设计模式做什么用的？" class="headerlink" title="设计模式做什么用的？"></a>设计模式做什么用的？</h1><p>让你的代码可重用性强点、让代码看起来容易被理解点、让代码的可靠性高点（不至于修改一处，引发很多其他问题），让代码的更加结构化点…</p>
<p>由于本人主做java，故主要用java来说明自己对设计模式的一些理解，万丈高楼起于平地，就先从最简单的单例模式开始记录吧。</p>
<p>java的单例模式是一种常见模式，大体归结为2大类：懒汉式单例、饿汉式单例（比如：登记式单例，枚举式单例…等等，我觉得只是实现的方式不同）；</p>
<p>单例模式的特点：<br>1 一个类的的实例只能有一个。（本质就是在内存中有且只有一个引用地址）<br>2 单例类必须自己创建自己的实例。（不能有其他的创建方式，保证唯一性）<br>3 单例类必须管理自己的这个实例，提供给外部唯一访问实例的函数（保证实例使用时的唯一性）；</p>
<h1 id="一-懒汉式单例"><a href="#一-懒汉式单例" class="headerlink" title="一 懒汉式单例"></a>一 懒汉式单例</h1><p>只有在自身需要的时候才会创建，没有提前创建好存在内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//懒汉式单例类</div><div class="line">public class Singleton &#123;  </div><div class="line">  private Singleton() &#123;&#125;  //构造方法私有化，保证创建方法唯一</div><div class="line">  private static Singleton single=null;  </div><div class="line">  //提供对外的唯一访问方法</div><div class="line">  public static Singleton getInstance() &#123;  </div><div class="line">    if (single == null) &#123;    </div><div class="line">        single = new Singleton();  </div><div class="line">    &#125;    </div><div class="line">        return single;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们都知道java代码会被编译程class字节码文件，然后在JVM中执行，那么在当前的JVM中，这个类的内存引用地址就应该是唯一的，Singleton类在初次调用是实例化自己，通过构造方法的private私有化，保证不能被外部创建，同时提供getInstance()方法，唯一访问方式（途径），管理好自己的实例。</p>
<font color="#FF0000" size="3">注：因为java存在反射的机制，它是能够实例化构造方法为private的类，我们也可以修改构造器，让它在创建第二个实例的时候抛异常。</font>

<p>以上简单的例子，在java的编程中并不完善，因为我们还要考虑到多线程的情况，如果多条线程中同时使用Singleton类的实例，通过getInstance()方法，如果当前类还没有被实例化那么就会new Singleton（），创建引用地址并且分配内存，如果没有同步，就容易出现问题：例如（当Singleton还是null的时候 A线程调用getInstance()，程序会去new Singleton(),假使此刻Singleton的对象还在创建中，B线程又调用了getInstance（），那么就又会去创建，此时就有可能内存中有2个Singleton对象。） 因此我们还可以这样改造一下这个getInstance（）方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static synchronized Singleton getInstance() &#123;  </div><div class="line">         if (single == null) &#123;    </div><div class="line">             single = new Singleton();  </div><div class="line">         &#125;    </div><div class="line">        return single;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们试着给这个方法加上synchronized ，使它变成同步方法，或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static Singleton getInstance() &#123;  </div><div class="line">        if (singleton == null) &#123;    </div><div class="line">            synchronized (Singleton.class) &#123;    </div><div class="line">               if (singleton == null) &#123;    </div><div class="line">                  singleton = new Singleton();   </div><div class="line">               &#125;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        return singleton;   </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们用当前对象作为同步锁，2次非null判断，同时lock object也是可以的，这样就可以避免上述所说的情况。</p>
<h1 id="二-饿汉式单例"><a href="#二-饿汉式单例" class="headerlink" title="二 饿汉式单例"></a>二 饿汉式单例</h1><p>当使用这个类的时候 本身作为静态成员变量立马被创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//饿汉式单例类.在类初始化时，已经自行实例化   </div><div class="line">public class Singleton1 &#123;  </div><div class="line">    private Singleton1() &#123;&#125;  </div><div class="line">    private static final Singleton1 single = new Singleton1();  </div><div class="line">    //静态工厂方法   </div><div class="line">    public static Singleton1 getInstance() &#123;  </div><div class="line">        return single;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饿汉式单例在类创建的同时本身作为静态的成员变量就已经被创建好，所以我们通过getInstance()获取使用时永远都是，所以天生是线程安全的single这个静态实例。因此这种写法也是线程安全的。</p>
<p>以上是单例模式的简单形式，在实际应用中，往往有时候还是会出现各种坑的，所以我们还可以继续完善一下。</p>
<h1 id="三-单例的不同实现形式和优化"><a href="#三-单例的不同实现形式和优化" class="headerlink" title="三 单例的不同实现形式和优化"></a>三 单例的不同实现形式和优化</h1><p>1 兼顾线程安全和效率的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">   private static volatile Singleton singleton = null;  </div><div class="line">   private Singleton()&#123;&#125;  </div><div class="line">   public static Singleton getSingleton()&#123;</div><div class="line">       if(singleton == null)&#123;</div><div class="line">           synchronized (Singleton.class)&#123;</div><div class="line">               if(singleton == null)&#123;</div><div class="line">                   singleton = new Singleton();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return singleton;</div><div class="line">   &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种写法被称为“双重检查锁”，就是在getSingleton()方法中，进行两次null检查。看似多此一举，但实际上却极大提升了并发度，进而提升了性能。为什么可以提高并发度呢？就像上面说的，在单例中new的情况非常少，绝大多数都是可以并行的读操作。因此在加锁前多进行一次null检查就可以减少绝大多数的加锁操作，执行效率提高的目的也就达到了。</p>
<font color="#FF0000" size="3">注： volatile 关键字修饰 JDK1.5之前对这个支持不是很好。</font>

<p>2 静态内部类法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static class Holder &#123;</div><div class="line">        private static Singleton singleton = new Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Singleton()&#123;&#125;</div><div class="line"></div><div class="line">    public static Singleton getSingleton()&#123;</div><div class="line">        return Holder.singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把Singleton实例放到一个静态内部类中，这样避免了静态实例在Singleton类加载的时候就创建对象，并且由于静态内部类只会被加载一次，所以这种写法也是线程安全的.</p>
<p>3 枚举写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    private String name;</div><div class="line">    public String getName()&#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public void setName(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用枚举除了线程安全和防止反射强行调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。个人一般在java中很少写枚举，占用资源多尤其在android的开发中不建议使用。</p>
<p>4 登记式单例</p>
<p>原理： 登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。</p>
<p>这个可以忽略，我想也几乎没人去这样写的吧。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="1-饿汉式和懒汉式区别："><a href="#1-饿汉式和懒汉式区别：" class="headerlink" title="1 饿汉式和懒汉式区别："></a>1 饿汉式和懒汉式区别：</h2><p>懒汉模式在运行的时候 获取对象比较慢，但是加载类的时候比较快。<br>饿汉模式是在运行的时候获取对象较快，加载类的时候慢。</p>
<h2 id="2-线程安全："><a href="#2-线程安全：" class="headerlink" title="2 线程安全："></a>2 线程安全：</h2><p>懒汉模式一是般非线程安全的，所以在写的同时注意同步。<br>饿汉式一般就是线程安全的。</p>
<h2 id="3-序列化与反序列化安全："><a href="#3-序列化与反序列化安全：" class="headerlink" title="3 序列化与反序列化安全："></a>3 序列化与反序列化安全：</h2><p> 对象在序列化后，如果反序列化又可能会创建新的对象，枚举单例写法提供反序列化机制可以避免此类问题。</p>]]></content>
      
        
        <tags>
            
            <tag> java 设计模式 android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ImageView的scaleType属性分析结果]]></title>
      <url>/2017/05/16/ImageView%E7%9A%84scaleType%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C/</url>
      <content type="html"><![CDATA[<p>记录Android中ImageView的scaleType的各个属性<br><a id="more"></a></p>
<p>在android中一般主要用ImageView来显示图片，那么关于图片的比例缩放，及显示图片的整体还是部分等等，我们可以使用scaleType来设置对应的显示模式。<br>使用方式：<br>（1）在xml布局文件中 android:scaleType=”center”；<br>（2）在代码中：imageView.setScaleType(ImageView.ScaleType.CENTER);</p>
<p>下面是几种结果实际测试对比结果：<br>首先是横图和竖图的原图：</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/ImageView.jpg" alt="image"></p>
<p>（1）ImageView.ScaleType.CENTER | android:scaleType=”center” </p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/imageview_center.jpg" alt="image"></p>
<p>以原图的几何中心点和ImagView的几何中心点为基准,按图片的原来size居中显示，不缩放；<br>当图片长/宽超过View的长/宽，则截取图片的居中部分显示ImageView的size；<br>当图片小于View 的长宽时，只显示图片的size,不放大。</p>
<font color="#FF0000" size="3" face="关键字：不缩放,截图">关键字：不缩放,截图</font>


<p>（2）ImageView.ScaleType.CENTER_CROP | android:scaleType=”centerCrop”</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/imageview_centerCrop.jpg" alt="image"></p>
<p>以原图的几何中心点和ImagView的几何中心点为基准，按比例扩大图片原图片的size居中显示；使得图片长 (宽)等于或大于View的长(宽),并按View的大小截取图片。<br>当原图的size大于ImageView时，按比例缩小原图片，使得原图的size大于等于ImageView的大小。</p>
<font color="#FF0000" size="3" face="关键字：按比例缩放，截图">关键字：按比例缩放，截图</font>


<p>（3）ImageView.ScaleType.CENTER_INSIDE | android:scaleType=”centerInside”</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/imageview_centerSide.jpg" alt="image"></p>
<p>以原图的几何中心点和ImagView的几何中心点为基准；<br>当原图片大于imageView的size时，缩小原图，使其小于等于imageView，将图片的内容完全居中显示。<br>当原图片小于imageView的size时，不放大原图，居中显示原图片。</p>
<font color="#FF0000" size="3" face="关键字：将图片的内容完整居中显示，不放大，只缩小">关键字：将图片的内容完整居中显示，不放大，只缩小</font>


<p>（4）ImageView.ScaleType.FIT_CENTER | android:scaleType=”fitCenter”</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/imageview_fitCenter.jpg" alt="image"></p>
<p>以原图的几何中心点和ImagView的几何中心点为基准；<br>原图片按比例扩大(缩小)到View的宽度（短的边），居中显示，显示全部图片。<br>通过按比例缩小(扩大)原图片来的size使得图片长(宽)等于或小于ImageView的长(宽)。</p>
<font color="#FF0000" size="3" face="关键字：按比例缩放，居中显示全图">关键字：按比例缩放，居中显示全图</font>



<p>（5）ImageView.ScaleType.FIT_END | android:scaleType=”fitEnd”    </p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/imageview_fitend.jpg" alt="image"></p>
<p>以原图的右下角和ImagView的右下角为基准；<br>原图片按比例扩大(缩小)到View的宽度，显示在ImageView的下部分靠右位置。</p>
<font color="#FF0000" size="3" face="关键字：按比例缩放，靠右显示全图">关键字：按比例缩放，靠右显示全图</font>


<p>（6）ImageView.ScaleType.FIT_START | android:scaleType=”fitStart”</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/imageview_fitStart.jpg" alt="image"></p>
<p>以原图的右下角和ImagView的右下角为基准；<br>原图片按比例扩大(缩小)到View的宽度，显示在ImageView的上部分靠左位置。</p>
<font color="#FF0000" size="3" face="关键字：按比例缩放，靠左显示全图">关键字：按比例缩放，靠左显示全图</font>


<p>（7）ImageView.ScaleType.FIT_XY | android:scaleType=”fitXY”</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/imageview_fitXY.jpg" alt="image"></p>
<p>原图片按照指定的大小在ImageView中显示，拉伸显示图片，不保持原比例，全部显示图片填满ImageView；</p>
<font color="#FF0000" size="3" face="关键字：不保持比例，拉伸显示全图，填满ImageView">关键字：不保持比例，拉伸显示全图，填满ImageView。</font>


<p>（8）ImageView.ScaleType.MATRIX | android:scaleType=”matrix”</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/imageview_matirx.jpg" alt="image"></p>
<p>原图片按照指定的大小在ImageView中显示，不扩大（缩小），截取原图的上部分靠左位置<br>直接绘制在ImagView上显示；</p>
<font color="#FF0000" size="3" face="关键字：不扩大缩小，截图（原图上部分靠左位置）">关键字：不扩大缩小，截图（原图上部分靠左位置）。</font>]]></content>
      
        
        <tags>
            
            <tag> Android ImageView scaleType </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AndroidStudio及异常问题记录]]></title>
      <url>/2017/05/15/AndroidStudio%E5%8F%8A%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>记录AndroidStudio使用中问题和开发中异常…<br><a id="more"></a></p>
<p>1 首次启动studio卡死解决：到android studio的安装目录的bin目录下去找这个文件：idea.properties 文件，在文件的最后追加这样一句话即可：disable.android.first.run=true</p>
<p>2 导入其他地方的项目卡死（很慢） 从github或其他地方导入项目如果studio很久也是像卡死的状态，这时你可以先将进程杀死，沿着这个路径：项目/gradle/wrapper找到这个文件：gradle-wrapper.properties 查看gradle的版本号。</p>
<p>解决：（1）去</p>
<p><a href="http://services.gradle.org/distributions" target="_blank" rel="external">http://services.gradle.org/distributions</a></p>
<p>下载对应版本然后将下载好的这个文件（比如：gradle-2.10-all.zip）拷贝到这个目录下：</p>
<blockquote>
<p>C:\Users\用户名.gradle\wrapper\dists\gradle-2.10all\a4w5fzrkeut1ox71xslb49gst</p>
</blockquote>
<p>注：a4w5fzrkeut1ox71xslb49gst这个文件夹名是随机数所以很可能不是一样的，然后再导入项目。</p>
<p>（2）另一种方法是，将上面那个文件的版本改成你自己那个目录有的版本，然后再导入项目</p>
<p>具体参见链接地址：</p>
<p><a href="http://www.jianshu.com/p/e1c0b46e317c" target="_blank" rel="external">http://www.jianshu.com/p/e1c0b46e317c</a></p>
<p>3 加快android studio的运行速度：进入AS安装目录bin下面，找到studio64.exe.vmoptions文件，进入从上到下第二个开始一次修改为，1500m,500m，96m之后重新打开AS即可。</p>
<p>4 在android studio中指定（替换）keystore签名文件首先在build下点击genereta singled APK,之后完善对应信息并且最后选择debug在finsh。（clean一下）之后在使用项目的build gradle文件中android{}下面配置如下片段例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">signingConfigs &#123;</div><div class="line">    config &#123;</div><div class="line">    keyAlias &apos;123&apos;</div><div class="line">    keyPassword &apos;123&apos;</div><div class="line">    storeFile file(&apos;签名文件路径&apos;)</div><div class="line">    storePassword &apos;123&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后clean一下项目，运行即可</p>
<p>5 adnroid studio下ndk使用<br>  1 下载ndk<br>  2 配置ndk环境变量<br>  3 在cmd中进入到对应到libs库下面 的so库文件目录，之后执行ndk-buil重新编译。</p>
<p>6 dexDebug ExecException finished with non-zero exit value 2 异常<br>  需要在gradle中配置下面的代码，原因是引用了多个libraries文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">    multiDexEnabled true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7 Execution failed for task ‘:app:transformClassesWithJarMergingForDebug’.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">com.android.build.api.transform.ransformException:java.util.zip.ZipException:duplicate entry:android/support/v4/app/BackStackState$1.class</div></pre></td></tr></table></figure></p>
<p>原因：在所添加的jar包或aar包中也引用了support-V4,与工程中引用的相冲突<br>Ctrl+N –&gt; 在搜索框中输入BackStackState –&gt; 查找到所有引用该类的类，这些类即为引起冲突的类<br>去掉本工程中gradle中用于引用有冲突的包的代码或者将冲突的代码从jar包或aar包中移除，确保一个module中只引用了一份相同的第三方包</p>
<p>8 Could not find property” error. signingConfigs(配置打包签名的时候，提示找不到这个属性签名文件)</p>
<p>解决：在gradle的文件中把signingConfigs的配置放在buildTypes类型的代码上面 （gradle 按照顺序执行）</p>
<p>9 解决Android Studio编译后安装apk报错：The APK file does not exist on disk<br>  解决：打开当前的工程，在最右侧的gradle中重新build一下，在编译安装</p>
<p>10 android wifi连接adb<br> cmd中执行 adb tcpip 5555<br> 之后执行 adb connect (手机wifi地址，wifi搞基设置中查看)：5555  </p>
<p>11 android studio中clean或者build出现如下异常</p>
<p><img src="http://opdge5lf7.bkt.clouddn.com/1.png" alt="image"></p>
<p>出现原因：因为当前项目下对应的 .gradle中的编译缓存文件损坏，<br>导致每次编译读取缓存中的属性，最终每次出错。</p>
<p>解决办法：进入当前项目下，找到.gradle文件，在当前gradle版本文件夹下面找到taskArtifacts文件夹<br>整个删除，重新clean生成，就ok。</p>
<p>删除位置：<img src="http://opdge5lf7.bkt.clouddn.com/2.png" alt="image"></p>]]></content>
      
        
        <tags>
            
            <tag> AS AndroidStudio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义CircleGroup]]></title>
      <url>/2017/04/26/%E8%87%AA%E5%AE%9A%E4%B9%89CircleGroup/</url>
      <content type="html"><![CDATA[<p>一个自定义CircleGroup<br><a id="more"></a></p>
<p>github地址: <a href="https://github.com/lishuxiong/CircleGroup" target="_blank" rel="external">https://github.com/lishuxiong/CircleGroup</a></p>
<p>效果图：<br><img src="http://opdge5lf7.bkt.clouddn.com/circle.gif" alt="image">  </p>]]></content>
      
        
        <tags>
            
            <tag> Android View </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
